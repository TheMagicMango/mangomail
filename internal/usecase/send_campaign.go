package usecase

import (
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/TheMagicMango/mangomail/internal/infra/reader"
	"github.com/TheMagicMango/mangomail/pkg/events"
	"github.com/resend/resend-go/v2"
)

type SendCampaignInputDTO struct {
	CampaignName string
	HTMLPath     string
	SamplePath   string
	From         string
	Subject      string
	ReplyTo      string
	Attachments  []string
	RateLimit    uint64
}

type SendCampaignOutputDTO struct {
	CampaignName    string
	TotalRecipients int
	SentCount       int
	FailCount       int
	Duration        time.Duration
}

type SendCampaignUseCase struct {
	EmailSentEvent  events.EventInterface
	EventDispatcher events.EventDispatcherInterface
	Reader          reader.Reader
}

func NewSendCampaignUseCase(
	emailSentEvent events.EventInterface,
	eventDispatcher events.EventDispatcherInterface,
	fileReader reader.Reader,
) *SendCampaignUseCase {
	return &SendCampaignUseCase{
		EmailSentEvent:  emailSentEvent,
		EventDispatcher: eventDispatcher,
		Reader:          fileReader,
	}
}

func (uc *SendCampaignUseCase) Execute(input SendCampaignInputDTO) (*SendCampaignOutputDTO, error) {
	startTime := time.Now()

	htmlContent, err := uc.Reader.LoadHTML(input.HTMLPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load HTML: %w", err)
	}

	csvRows, err := uc.Reader.LoadCSV(input.SamplePath)
	if err != nil {
		return nil, fmt.Errorf("failed to load CSV: %w", err)
	}

	attachments := uc.prepareAttachments(input.Attachments)

	if err := uc.sendEmailsInBatches(input, htmlContent, csvRows, attachments); err != nil {
		return nil, err
	}

	duration := time.Since(startTime)

	if err := uc.generateReport(input, len(csvRows), startTime, time.Now(), duration); err != nil {
		return nil, fmt.Errorf("failed to generate report: %w", err)
	}

	slog.Info("Campaign completed", "campaign", input.CampaignName, "duration", duration)

	return &SendCampaignOutputDTO{
		CampaignName:    input.CampaignName,
		TotalRecipients: len(csvRows),
		SentCount:       len(csvRows),
		FailCount:       0,
		Duration:        duration,
	}, nil
}

func (uc *SendCampaignUseCase) prepareAttachments(urls []string) []*resend.Attachment {
	if len(urls) == 0 {
		return nil
	}

	attachments := make([]*resend.Attachment, len(urls))
	for i, url := range urls {
		attachments[i] = &resend.Attachment{Path: url}
	}
	return attachments
}

func (uc *SendCampaignUseCase) sendEmailsInBatches(input SendCampaignInputDTO, htmlContent string, csvRows []map[string]interface{}, attachments []*resend.Attachment) error {
	batchSize := int(input.RateLimit)
	totalRows := len(csvRows)

	for i := 0; i < totalRows; i += batchSize {
		end := i + batchSize
		if end > totalRows {
			end = totalRows
		}

		batch := csvRows[i:end]

		for _, row := range batch {
			emailReq := &resend.SendEmailRequest{
				From:        input.From,
				To:          []string{row["email"].(string)},
				Subject:     uc.replacePlaceholders(input.Subject, row),
				Html:        uc.replacePlaceholders(htmlContent, row),
				Attachments: attachments,
			}

			if input.ReplyTo != "" {
				emailReq.ReplyTo = input.ReplyTo
			}

			uc.EmailSentEvent.SetPayload(emailReq)
			if err := uc.EventDispatcher.Dispatch(uc.EmailSentEvent); err != nil {
				slog.Error("Failed to dispatch email event", "email", row["email"], "error", err)
			}
		}

		if end < totalRows {
			slog.Info("Waiting before next batch", "sent", end, "total", totalRows, "delay", time.Second)
			time.Sleep(time.Second)
		}
	}

	return nil
}

func (uc *SendCampaignUseCase) generateReport(
	input SendCampaignInputDTO,
	totalRecipients int,
	startTime, endTime time.Time,
	duration time.Duration,
) error {
	reportDir := ".mangomail"
	if err := os.MkdirAll(reportDir, 0755); err != nil {
		return fmt.Errorf("failed to create report directory: %w", err)
	}

	timestamp := time.Now().Format("20060102-150405")
	reportPath := filepath.Join(reportDir, fmt.Sprintf("%s.md", timestamp))

	content := fmt.Sprintf(`# Email Campaign Report: %s

**Generated:** %s

## Campaign Details
- **Campaign Name:** %s
- **HTML Template:** %s
- **CSV File:** %s
- **From:** %s
- **Subject:** %s
- **Attachments:** %v

## Statistics
- **Total Recipients:** %d

## Execution Summary
- **Started at:** %s
- **Completed at:** %s
- **Duration:** %s

---
*Generated by MangoMail*
`,
		input.CampaignName,
		time.Now().Format(time.RFC3339),
		input.CampaignName,
		input.HTMLPath,
		input.SamplePath,
		input.From,
		input.Subject,
		input.Attachments,
		totalRecipients,
		startTime.Format(time.RFC3339),
		endTime.Format(time.RFC3339),
		duration.String(),
	)

	if err := os.WriteFile(reportPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write report: %w", err)
	}

	slog.Info("Report generated", "path", reportPath)
	return nil
}

func (uc *SendCampaignUseCase) replacePlaceholders(text string, row map[string]interface{}) string {
	re := regexp.MustCompile(`\{\{(\s*\w+\s*)\}\}`)

	return re.ReplaceAllStringFunc(text, func(match string) string {
		fieldName := strings.TrimSpace(match[2 : len(match)-2])

		if value, ok := row[fieldName]; ok {
			return fmt.Sprintf("%v", value)
		}

		return match
	})
}
